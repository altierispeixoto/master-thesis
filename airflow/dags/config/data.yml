base_url: "http://dadosabertos.c3sl.ufpr.br/curitibaurbs/"

etl_tasks:
  tabela_linhas:
    folder: linhas
    file: linhas.json.xz

  pontos_linha:
    folder: pontoslinha
    file: pontosLinha.json.xz

  tabela_linha:
    folder: tabelalinha
    file: tabelaLinha.json.xz

  tabela_trechositinerarios:
    folder: trechositinerarios
    file: trechosItinerarios.json.xz

  tabela_tabelaveiculo:
    folder: tabelaveiculo
    file: tabelaVeiculo.json.xz

  tabela_veiculos:
    folder: veiculos
    file: veiculos.json.xz


neo4j_import:
  lines:
    cypher_query: >
      LOAD CSV WITH HEADERS FROM 'file:///lines/{datareferencia}/lines.csv' AS row
      MERGE (l:Line {line_code: row.cod , name: row.nome, category: row.categoria_servico, color: row.nome_cor, card_only: row.somente_cartao  })


  lines_timetree:
    cypher_query: >
      LOAD CSV WITH HEADERS FROM 'file:///lines/{datareferencia}/lines.csv' AS row
      with row where NOT toInteger(row.year) IS NULL
      match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)}), (l:Line {line_code:row.cod,name:row.nome})
      merge (d)-[r2:EXISTS_LINE]->(l)

  vehicles:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
      with distinct row.vehicle as vehicle where NOT vehicle = ""
      merge (v:Vehicle {vehicle:vehicle})

  vehicles2:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
      with distinct row.vehicle as vehicle where NOT vehicle = ""
      merge (v:Vehicle {vehicle:vehicle})

  busstops:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM 'file:///busstops/{datareferencia}/busstops.csv' AS row
      MERGE (bs:BusStop {number: row.num, name: row.nome, type: row.tipo, geometry: 'POINT(' + row.lon +' '+ row.lat +')', latitude: row.lat, longitude: row.lon })

  trip_endpoints:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM "file:///trip-endpoints/{datareferencia}/trip-endpoints.csv" AS row
      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.line_code}),(bs0:BusStop {number:row.origin}),(bs1:BusStop {number:row.destination})
      MERGE (l)-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})
      MERGE (t)-[:STARTS_ON_POINT]->(bs0)
      MERGE (t)-[:ENDS_ON_POINT]->(bs1)

  trip_bus_stops:
    cypher_query: >
      LOAD CSV WITH HEADERS FROM "file:///busstops/{datareferencia}/busstops.csv" AS row  
      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.cod_linha})-[:HAS_TRIP]->(t:Trip {line_way:row.sentido_linha}), (bs:BusStop {number: row.num})
      merge (t)-[:HAS_BUS_STOP]->(bs)
 
  
  routes:
    cypher_query: >
      USING PERIODIC COMMIT 21000
      LOAD CSV WITH HEADERS FROM "file:///routes/{datareferencia}/routes.csv" AS row
      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.cod_linha})-[:HAS_TRIP]->(t:Trip {line_way:row.sentido_linha})-[:HAS_BUS_STOP]->(bss: BusStop {number: row.ponto_inicio})
      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.cod_linha})-[:HAS_TRIP]->(t:Trip {line_way:row.sentido_linha})-[:HAS_BUS_STOP]->(bse: BusStop {number: row.ponto_final})
      MERGE (bss) -[r:NEXT_STOP {
                         line_code: row.cod_linha
                        ,line_way: row.sentido_linha
                        ,service_category: row.categoria_servico
                        ,line_name: row.nome_linha
                        ,color_name: row.nome_cor
                        ,card_only: row.somente_cartao
      }]->(bse)
      ON CREATE SET 
        r.distance = distance(point({longitude: toFloat(bss.longitude),latitude: toFloat(bss.latitude) ,crs: 'wgs-84'})
        ,point({longitude: toFloat(bse.longitude),latitude: toFloat(bse.latitude) ,crs: 'wgs-84'}))

  schedules:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table ="" and not row.start_point = "" and not row.sentido = ""
      MERGE (s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point:row.start_point, year: toInteger(row.year), month: toInteger(row.month), day: toInteger(row.day), vehicle:row.vehicle, line_way:row.sentido})
  
  trip_schedules:
    cypher_query: >
        USING PERIODIC COMMIT 10000
        LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
        with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""  and not row.start_point = ""
        match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[r2:EXISTS_LINE]->(l:Line {line_code:row.line_code} )-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})-[:STARTS_ON_POINT]->(bs:BusStop {number:row.start_point}) ,
        (s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point:row.start_point, year:toInteger(row.year), month:toInteger(row.month), day:toInteger(row.day), vehicle:row.vehicle, line_way:row.sentido})
        MERGE (t)-[:HAS_SCHEDULE_AT]->(s)

  vehicle_schedules:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""  and not row.start_point = ""
      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[r2:EXISTS_LINE]->(l:Line {line_code:row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})-[:STARTS_ON_POINT]->(bs:BusStop {number:row.start_point})
      MATCH (t)-[:HAS_SCHEDULE_AT]->(s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point:row.start_point, year:toInteger(row.year), month:toInteger(row.month), day:toInteger(row.day), vehicle:row.vehicle, line_way:row.sentido}), (v:Vehicle {vehicle: row.vehicle})
      MERGE (s)-[:HAS_VEHICLE_SCHEDULED]->(v)

  stops:
    cypher_query: >    
      USING PERIODIC COMMIT 15000
      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
      MERGE (s:Stop {vehicle:row.vehicle, geometry : 'POINT(' + row.longitude +' '+ row.latitude +')', latitude:row.latitude, longitude:row.longitude, event_timestamp:row.stop_timestamp, event_time:row.event_time,line_code: row.cod_linha})

  stops_timetree:
    cypher_query: >
      USING PERIODIC COMMIT 20000
      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
      match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:CONTAINS]->(h:Hour {value: toInteger(row.hour)}), (s:Stop {latitude:row.latitude, longitude:row.longitude,event_timestamp:row.stop_timestamp, event_time:row.event_time,line_code: row.cod_linha})
      merge (h)-[:EXISTS_STOP]->(s)

  event-stop-edges: #event-stop-edges.csv
    cypher_query: >
      USING PERIODIC COMMIT 20000
      LOAD CSV WITH HEADERS FROM "file:///event-stop-edges/{datareferencia}/event-stop-edges.csv" AS row
      MATCH (s:Stop {line_code:row.line_code,latitude:row.latitude,longitude:row.longitude,event_time:row.event_time}),(bs:BusStop {number:row.bus_stop_number})
      create (s)-[e:EVENT_STOP {line_way:row.line_way}]->(bs)

  trackingdata: #trackingdata.csv
    cypher_query: >
      USING PERIODIC COMMIT 20000
      LOAD CSV WITH HEADERS FROM 'file:///trackingdata/{datareferencia}/trackingdata.csv' AS row
      with row where toFloat(row.delta_time) <= 1200
      MATCH (s0:Stop {line_code: row.cod_linha, vehicle:row.veic, event_timestamp:row.last_stop}), (s1:Stop {line_code: row.cod_linha, vehicle:row.veic, event_timestamp:row.current_stop})
      create (s0)-[m:MOVED_TO {delta_time: row.delta_time, delta_distance: row.delta_distance, delta_velocity:row.delta_velocity}]->(s1)

