base_url: "http://dadosabertos.c3sl.ufpr.br/curitibaurbs/"

etl_tasks:
  tabela_linhas:
    folder: linhas
    file: linhas.json.xz

  pontos_linha:
    folder: pontoslinha
    file: pontosLinha.json.xz

  tabela_linha:
    folder: tabelalinha
    file: tabelaLinha.json.xz

  tabela_trechositinerarios:
    folder: trechositinerarios
    file: trechosItinerarios.json.xz

  tabela_tabelaveiculo:
    folder: tabelaveiculo
    file: tabelaVeiculo.json.xz

  tabela_veiculos:
    folder: veiculos
    file: veiculos.json.xz


neo4j_import:

  #color,year,month,day
  color:
    cypher_query: >
      LOAD CSV WITH HEADERS FROM 'file:///color/{datareferencia}/color.csv' AS row
      MERGE (c:Color {value: row.color})
      return count(*)

    #service_category,year,month,day
    service_category:
      cypher_query: >
        LOAD CSV WITH HEADERS FROM 'file:///service_category/{datareferencia}/service_category.csv' AS row
        MERGE (s:ServiceCategory {value: row.service_category})
        return count(*)

    #service_category,line_name,line_code,color,card_only,year,month,day
    lines:
      cypher_query: >
        LOAD CSV WITH HEADERS FROM 'file:///lines/{datareferencia}/lines.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})
        MATCH (c:Color {value:row.color})
        MATCH (s:ServiceCategory {value:row.service_category})
        with d,c,s,row
        MERGE (l:Line {line_code: row.line_code, line_name: row.line_name,card_only:row.card_only})
        MERGE (d)-[:HAS_LINE]->(l)
        MERGE (l)-[:HAS_COLOR]->(c)
        MERGE (l)-[:HAS_SERVICE_CATEGORY]-(s)
        return count(*)

    # line_code,start_point,end_point,start_time,timetable,vehicle,end_time,line_way,year,month,day
    trips:
      cypher_query: >
        USING PERIODIC COMMIT 1000
        LOAD CSV WITH HEADERS FROM 'file:///trips/{datareferencia}/trips.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})
        WITH l, row
        MERGE (t:Trip {start_point: row.start_point, end_point: row.end_point, start_time:row.start_time,timetable:row.timetable, end_time: row.end_time, line_way:row.line_way })
        MERGE (l)-[:HAS_TRIP]->(t)
        return count(*)

    # type,year,month,day
    bus_stop_type:
      cypher_query: >
        LOAD CSV WITH HEADERS FROM 'file:///bus_stop_type/{datareferencia}/bus_stop_type.csv' AS row
        MERGE (t:BusStopType {value: row.type})
        return count(*)

    #line_code,line_way,number,name,seq,latitude,longitude,type,year,month,day
    bus_stops:
      cypher_query: >
        USING PERIODIC COMMIT 10000
        LOAD CSV WITH HEADERS FROM 'file:///bus_stops/{datareferencia}/bus_stops.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})
        MATCH (bst:BusStopType {value: row.type})
        WITH t, row
        MERGE (t)-[:HAS_BUS_STOP]->(bs:BusStop {number: row.number, name: row.name, latitude: row.latitude, longitude:row.longitude})
        MERGE (bs)-[:HAS_TYPE]->(bst)
        return count(*)

    #line_code,line_way,start_seq,end_seq,start_point,end_point,year,month,day
    line_routes:
      cypher_query: >
        USING PERIODIC COMMIT 10000
        LOAD CSV WITH HEADERS FROM 'file:///line_routes/{datareferencia}/line_routes.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})
        MATCH (t)-[:HAS_BUS_STOP]->(bss:BusStop {number:row.start_point})
        MATCH (t)-[:HAS_BUS_STOP]->(bse:BusStop {number:row.end_point})
        MERGE (bss) -[r:NEXT_STOP {line_code: row.line_code, line_way: row.line_way}]->(bse)
        ON CREATE SET
            r.distance = distance(point({longitude: toFloat(bss.longitude),latitude: toFloat(bss.latitude) ,crs: 'wgs-84'})
            ,point({longitude: toFloat(bse.longitude),latitude: toFloat(bse.latitude) ,crs: 'wgs-84'}))

    #line_code,line_way,start_point,end_point,year,month,day
    trip_endpoints:
      cypher_query: >
        USING PERIODIC COMMIT 10000
        LOAD CSV WITH HEADERS FROM 'file:///trip_endpoints/{datareferencia}/trip_endpoints.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})-[:HAS_BUS_STOP]->(bss:BusStop {number:row.start_point})
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})-[:HAS_BUS_STOP]->(bse:BusStop {number:row.end_point})
        MERGE(t)-[:STARTS_ON_POINT]->(bss)
        MERGE(t)-[:ENDS_ON_POINT]->(bse)

    #line_code,line_way,vehicle,moving_status,event_timestamp,latitude,longitude,avg_velocity,number,hour,year,month,day
    bus_event_edges:
      cypher_query: >
        LOAD CSV WITH HEADERS FROM 'file:///bus_event_edges/{datareferencia}/bus_event_edges.csv' AS row
        MERGE (bee:BusEventEdge {number: row.number, name: row.name, latitude: row.latitude, longitude:row.longitude})
        return count(*)

    #line_code,line_way,vehicle,moving_status,event_timestamp,latitude,longitude,avg_velocity,hour,year,month,day
    events:
      cypher_query: >
        LOAD CSV WITH HEADERS FROM 'file:///events/{datareferencia}/events.csv' AS row
        MERGE (ev:Event {number: row.number, name: row.name, latitude: row.latitude, longitude:row.longitude})
        return count(*)


#  lines_timetree:
#    cypher_query: >
#      LOAD CSV WITH HEADERS FROM 'file:///lines/{datareferencia}/lines.csv' AS row
#      with row where NOT toInteger(row.year) IS NULL
#      match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)}), (l:Line {line_code:row.cod,name:row.nome})
#      merge (d)-[r2:EXISTS_LINE]->(l)

#  vehicles:
#    cypher_query: >
#      USING PERIODIC COMMIT 10000
#      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
#      with distinct row.vehicle as vehicle where NOT vehicle = ""
#      merge (v:Vehicle {vehicle:vehicle})
#
#  vehicles2:
#    cypher_query: >
#      USING PERIODIC COMMIT 10000
#      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
#      with distinct row.vehicle as vehicle where NOT vehicle = ""
#      merge (v:Vehicle {vehicle:vehicle})
#
#  busstops:
#    cypher_query: >
#      USING PERIODIC COMMIT 10000
#      LOAD CSV WITH HEADERS FROM 'file:///busstops/{datareferencia}/busstops.csv' AS row
#      MERGE (bs:BusStop {number: row.num, name: row.nome, type: row.tipo, geometry: 'POINT(' + row.lon +' '+ row.lat +')', latitude: row.lat, longitude: row.lon })
#
#  trip_endpoints:
#    cypher_query: >
#      USING PERIODIC COMMIT 10000
#      LOAD CSV WITH HEADERS FROM "file:///trip-endpoints/{datareferencia}/trip-endpoints.csv" AS row
#      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.line_code}),(bs0:BusStop {number:row.origin}),(bs1:BusStop {number:row.destination})
#      MERGE (l)-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})
#      MERGE (t)-[:STARTS_ON_POINT]->(bs0)
#      MERGE (t)-[:ENDS_ON_POINT]->(bs1)
#
#  trip_bus_stops:
#    cypher_query: >
#      LOAD CSV WITH HEADERS FROM "file:///busstops/{datareferencia}/busstops.csv" AS row
#      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.cod_linha})-[:HAS_TRIP]->(t:Trip {line_way:row.sentido_linha}), (bs:BusStop {number: row.num})
#      merge (t)-[:HAS_BUS_STOP]->(bs)
#
#
#  routes:
#    cypher_query: >
#      USING PERIODIC COMMIT 21000
#      LOAD CSV WITH HEADERS FROM "file:///routes/{datareferencia}/routes.csv" AS row
#      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.cod_linha})-[:HAS_TRIP]->(t:Trip {line_way:row.sentido_linha})-[:HAS_BUS_STOP]->(bss: BusStop {number: row.ponto_inicio})
#      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.cod_linha})-[:HAS_TRIP]->(t:Trip {line_way:row.sentido_linha})-[:HAS_BUS_STOP]->(bse: BusStop {number: row.ponto_final})
#      MERGE (bss) -[r:NEXT_STOP {
#                         line_code: row.cod_linha
#                        ,line_way: row.sentido_linha
#                        ,service_category: row.categoria_servico
#                        ,line_name: row.nome_linha
#                        ,color_name: row.nome_cor
#                        ,card_only: row.somente_cartao
#      }]->(bse)
#      ON CREATE SET
#        r.distance = distance(point({longitude: toFloat(bss.longitude),latitude: toFloat(bss.latitude) ,crs: 'wgs-84'})
#        ,point({longitude: toFloat(bse.longitude),latitude: toFloat(bse.latitude) ,crs: 'wgs-84'}))
#
#  schedules:
#    cypher_query: >
#      USING PERIODIC COMMIT 10000
#      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
#      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table ="" and not row.start_point = "" and not row.sentido = ""
#      MERGE (s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point:row.start_point, year: toInteger(row.year), month: toInteger(row.month), day: toInteger(row.day), vehicle:row.vehicle, line_way:row.sentido})
#
#  trip_schedules:
#    cypher_query: >
#        USING PERIODIC COMMIT 10000
#        LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
#        with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""  and not row.start_point = ""
#        match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[r2:EXISTS_LINE]->(l:Line {line_code:row.line_code} )-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})-[:STARTS_ON_POINT]->(bs:BusStop {number:row.start_point}) ,
#        (s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point:row.start_point, year:toInteger(row.year), month:toInteger(row.month), day:toInteger(row.day), vehicle:row.vehicle, line_way:row.sentido})
#        MERGE (t)-[:HAS_SCHEDULE_AT]->(s)
#
#  vehicle_schedules:
#    cypher_query: >
#      USING PERIODIC COMMIT 10000
#      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
#      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""  and not row.start_point = ""
#      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[r2:EXISTS_LINE]->(l:Line {line_code:row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})-[:STARTS_ON_POINT]->(bs:BusStop {number:row.start_point})
#      MATCH (t)-[:HAS_SCHEDULE_AT]->(s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point:row.start_point, year:toInteger(row.year), month:toInteger(row.month), day:toInteger(row.day), vehicle:row.vehicle, line_way:row.sentido}), (v:Vehicle {vehicle: row.vehicle})
#      MERGE (s)-[:HAS_VEHICLE_SCHEDULED]->(v)
#
#  stops:
#    cypher_query: >
#      USING PERIODIC COMMIT 15000
#      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
#      MERGE (s:Stop {vehicle:row.vehicle, geometry : 'POINT(' + row.longitude +' '+ row.latitude +')', latitude:row.latitude, longitude:row.longitude, event_timestamp:row.stop_timestamp, event_time:row.event_time,line_code: row.cod_linha})
#
#  stops_timetree:
#    cypher_query: >
#      USING PERIODIC COMMIT 20000
#      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
#      match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:CONTAINS]->(h:Hour {value: toInteger(row.hour)}), (s:Stop {latitude:row.latitude, longitude:row.longitude,event_timestamp:row.stop_timestamp, event_time:row.event_time,line_code: row.cod_linha})
#      merge (h)-[:EXISTS_STOP]->(s)
#
#  event-stop-edges: #event-stop-edges.csv
#    cypher_query: >
#      USING PERIODIC COMMIT 20000
#      LOAD CSV WITH HEADERS FROM "file:///event-stop-edges/{datareferencia}/event-stop-edges.csv" AS row
#      MATCH (s:Stop {line_code:row.line_code,latitude:row.latitude,longitude:row.longitude,event_time:row.event_time}),(bs:BusStop {number:row.bus_stop_number})
#      create (s)-[e:EVENT_STOP {line_way:row.line_way}]->(bs)
#
#  trackingdata: #trackingdata.csv
#    cypher_query: >
#      USING PERIODIC COMMIT 20000
#      LOAD CSV WITH HEADERS FROM 'file:///trackingdata/{datareferencia}/trackingdata.csv' AS row
#      with row where toFloat(row.delta_time) <= 1200
#      MATCH (s0:Stop {line_code: row.cod_linha, vehicle:row.veic, event_timestamp:row.last_stop}), (s1:Stop {line_code: row.cod_linha, vehicle:row.veic, event_timestamp:row.current_stop})
#      create (s0)-[m:MOVED_TO {delta_time: row.delta_time, delta_distance: row.delta_distance, delta_velocity:row.delta_velocity}]->(s1)
#
