base_url: "http://dadosabertos.c3sl.ufpr.br/curitibaurbs/"

etl_tasks:
  tabela_linhas:
    folder: linhas
    file: linhas.json.xz

  pontos_linha:
    folder: pontoslinha
    file: pontosLinha.json.xz

  tabela_linha:
    folder: tabelalinha
    file: tabelaLinha.json.xz

  tabela_trechositinerarios:
    folder: trechositinerarios
    file: trechosItinerarios.json.xz

  tabela_tabelaveiculo:
    folder: tabelaveiculo
    file: tabelaVeiculo.json.xz

  tabela_veiculos:
    folder: veiculos
    file: veiculos.json.xz


neo4j_import:

  color:
    cypher_query: >
      LOAD CSV WITH HEADERS FROM 'file:///color/{datareferencia}/color.csv' AS row
      MERGE (c:Color {value: row.color})
      return count(*)

    service_category:
      cypher_query: >
        LOAD CSV WITH HEADERS FROM 'file:///service_category/{datareferencia}/service_category.csv' AS row
        MERGE (s:ServiceCategory {value: row.service_category})
        return count(*)

    lines:
      cypher_query: >
        USING PERIODIC COMMIT 20000
        LOAD CSV WITH HEADERS FROM 'file:///lines/{datareferencia}/lines.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})
        MATCH (c:Color {value:row.color})
        MATCH (s:ServiceCategory {value:row.service_category})
        with d,c,s,row
        MERGE (l:Line {line_code: row.line_code, line_name: row.line_name,card_only:row.card_only})
        MERGE (d)-[:HAS_LINE]->(l)
        MERGE (l)-[:HAS_COLOR]->(c)
        MERGE (l)-[:HAS_SERVICE_CATEGORY]-(s)
        return count(*)

    bus_stop_type:
      cypher_query: >
        LOAD CSV WITH HEADERS FROM 'file:///bus_stop_type/{datareferencia}/bus_stop_type.csv' AS row
        MERGE (t:BusStopType {value: row.type})
        return count(*)

    bus_stops:
      cypher_query: >
        USING PERIODIC COMMIT 10000
        LOAD CSV WITH HEADERS FROM 'file:///bus_stops/{datareferencia}/bus_stops.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})
        MATCH (bst:BusStopType {value: row.type})
        WITH bst, row, l
        MERGE (l)-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})
        MERGE (t)-[:HAS_BUS_STOP]->(bs:BusStop {number: row.number, name: row.name, latitude: row.latitude, longitude:row.longitude})
        MERGE (bs)-[:HAS_TYPE]->(bst)
        return count(*)

    trip_endpoints:
      cypher_query: >
        USING PERIODIC COMMIT 20000
        LOAD CSV WITH HEADERS FROM 'file:///trip_endpoints/{datareferencia}/trip_endpoints.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})
        MATCH (t)-[:HAS_BUS_STOP]->(bss:BusStop {number:row.start_point})
        MATCH (t)-[:HAS_BUS_STOP]->(bse:BusStop {number:row.end_point})
        MERGE (t)-[:STARTS_ON_POINT]->(bss)
        MERGE (t)-[:ENDS_ON_POINT]->(bse)
        return count(*)

    line_routes:
      cypher_query: >
        USING PERIODIC COMMIT 20000
        LOAD CSV WITH HEADERS FROM 'file:///line_routes/{datareferencia}/line_routes.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})
        MATCH (t)-[:HAS_BUS_STOP]->(bss:BusStop {number:row.start_point})
        MATCH (t)-[:HAS_BUS_STOP]->(bse:BusStop {number:row.end_point})
        MERGE (bss)-[r:NEXT_STOP {line_code: row.line_code, line_way: row.line_way}]->(bse)
        ON CREATE SET
            r.distance = distance(point({longitude: toFloat(bss.longitude),latitude: toFloat(bss.latitude) ,crs: 'wgs-84'})
            ,point({longitude: toFloat(bse.longitude),latitude: toFloat(bse.latitude) ,crs: 'wgs-84'}))
        return count(*)

    events:
      cypher_query: >
        USING PERIODIC COMMIT 30000
        LOAD CSV WITH HEADERS FROM 'file:///events/{datareferencia}/events.csv' AS row
        CREATE (ev:Event {vehicle: row.vehicle, moving_status: row.moving_status, event_timestamp:row.event_timestamp,latitude:row.latitude, longitude: row.longitude, avg_velocity: row.avg_velocity})
        return count(*)

    trip_has_events:
      cypher_query: >
        USING PERIODIC COMMIT 30000
        LOAD CSV WITH HEADERS FROM 'file:///events/{datareferencia}/events.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})
        MATCH (ev:Event {vehicle: row.vehicle, event_timestamp:row.event_timestamp})
        WITH  ev, t
        MERGE (t)-[:HAS_EVENT]->(ev)
        return count(*)

    time_has_events:
      cypher_query: >
        USING PERIODIC COMMIT 30000
        LOAD CSV WITH HEADERS FROM 'file:///events/{datareferencia}/events.csv' AS row
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:CONTAINS]->(h:Hour {value:toInteger(row.hour)})
        MATCH (ev:Event {vehicle: row.vehicle, event_timestamp:row.event_timestamp})
        WITH  ev, h
        MERGE (h)-[:HAS_EVENT]->(ev)
        return count(*)

    moves:
      cypher_query: >
        USING PERIODIC COMMIT 30000
        LOAD CSV WITH HEADERS FROM 'file:///events/{datareferencia}/events.csv' AS row
        with row where toInteger(row.delta_time_in_sec) > 0 and  toFloat(row.delta_time_in_sec) <= 1200
        MATCH (evi:Event {vehicle: row.vehicle, event_timestamp:row.last_timestamp}) , (evf:Event {vehicle: row.vehicle, event_timestamp:row.event_timestamp})
        create (evi)-[:MOVED_TO {delta_time_in_sec: row.delta_time_in_sec}]->(evf)
        return count(*)

    near_bus_stops:
      cypher_query: >
        USING PERIODIC COMMIT 20000
        LOAD CSV WITH HEADERS FROM 'file:///bus_event_edges/{datareferencia}/bus_event_edges.csv' AS row
        MATCH (evi:Event {vehicle: row.vehicle, event_timestamp:row.event_timestamp})
        MATCH (y:Year {value: toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code: row.line_code})-[:HAS_TRIP]->(t:Trip {line_way:row.line_way})-[:HAS_BUS_STOP]->(bs:BusStop {number: row.number})
        WITH bs, evi
        MERGE (evi)-[:IS_NEAR_BY]->(bs)
        return count(*)