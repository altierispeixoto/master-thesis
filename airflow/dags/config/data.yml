base_url: "http://dadosabertos.c3sl.ufpr.br/curitibaurbs/"

etl_tasks:
  tabela_linhas:
    folder: linhas
    file: linhas.json.xz

  pontos_linha:
    folder: pontoslinha
    file: pontosLinha.json.xz

  tabela_linha:
    folder: tabelalinha
    file: tabelaLinha.json.xz

  tabela_trechositinerarios:
    folder: trechositinerarios
    file: trechosItinerarios.json.xz

  tabela_tabelaveiculo:
    folder: tabelaveiculo
    file: tabelaVeiculo.json.xz

  tabela_veiculos:
    folder: veiculos
    file: veiculos.json.xz

etl_queries:
  lines:
      "(
          select distinct cod,
                        categoria_servico,
                        nome,
                        nome_cor,
                        somente_cartao,
                        year,
                        month,
                        day
                    from (
                        select l.cod,
                            l.categoria_servico,
                            l.nome,
                            l.nome_cor,
                            l.somente_cartao,
                            v.year as year,
                            v.month as month,
                            v.day as day
                        from veiculos v
                          right join linhas l on (v.cod_linha = l.cod and l.year = v.year and l.month = v.month  and l.day = v.day)
                           where  l.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                             and l.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                             and l.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
                          ) t
          order by cod, year, month, day
  ) q1"

  busstops:
      "(
                  with linhas as (
                          select  distinct cod,
                                  categoria_servico,
                                  nome,
                                  nome_cor,
                                  somente_cartao,
                                  year,
                                  month,
                                  day
                          from (
                              select l.cod,
                                  l.categoria_servico,
                                  l.nome,
                                  l.nome_cor,
                                  l.somente_cartao,
                                  v.year as year,
                                  v.month as month,
                                  v.day as day
                              from veiculos v
                              right join linhas l on (v.cod_linha = l.cod and l.year = v.year and l.month = v.month  and l.day = v.day)
                                   where  l.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                             and l.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                             and l.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
                            ) as l
                          )
                          select distinct
                                     pl.nome
                                    ,pl.num
                                    ,pl.tipo
                                    ,pl.lat
                                    ,pl.lon
                                    ,l.year
                                    ,l.month
                                    ,l.day
                          from     pontoslinha	pl
                          inner join linhas l on (pl.cod = l.cod and l.year = pl.year and l.month = pl.month  and l.day = pl.day )
    ) q1"

  routes: "(
          with vlinhas as (
          	select  distinct cod,
          	              year,
                          month,
                          day
          	       from (
                      select l.cod,
                             v.year as year,
                             v.month as month,
                             v.day as day
                      from veiculos v
                      right join linhas l on (v.cod_linha = l.cod and l.year = v.year and l.month = v.month  and l.day = v.day)
                      where  l.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                             and l.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                             and l.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
          		) as l
          	),
          	rota_sequenciada as  (
          		select 	  pseq.cod_linha
          		         ,pseq.sentido_linha
          		         ,pseq.seq_inicio
          		         ,pseq.seq_fim
          		         ,pseq.ponto_inicio
          		         ,pseq.nome_ponto_inicio
          		         ,pseq.ponto_final
          		         ,pseq.nome_ponto_final
          		         ,li.CATEGORIA_SERVICO as categoria_servico
          		         ,li.NOME as nome_linha
          		         ,li.NOME_COR as nome_cor
          		         ,li.SOMENTE_CARTAO as somente_cartao
          		         ,pseq.datareferencia
          		         from (
          		          		select
          		                	  p1.COD as cod_linha
          		                     ,p1.SENTIDO  as sentido_linha
          		                     ,p1.SEQ      as seq_inicio
          		                     ,p2.SEQ      as seq_fim
          		                     ,p1.NUM      as ponto_inicio
          		                     ,p1.NOME     as nome_ponto_inicio
          		                     ,p2.NUM      as ponto_final
          		                     ,p2.NOME     as nome_ponto_final
          		                     ,p1.datareferencia
          		                     	from pontoslinha p1
          		                     	inner join pontoslinha p2 on (cast(p1.SEQ as int) + 1 = cast(p2.SEQ as int) and p1.COD = p2.COD and p1.SENTIDO = p2.SENTIDO
          		                     	                               and p1.year = p2.year and p1.month = p2.month and p1.day = p2.day
          		                     	                               )
          		                     	where  p1.year  = cast(extract( YEAR from date '{datareferencia}') as varchar)
                            			   and p1.month = cast(extract( MONTH from date '{datareferencia}') as varchar)
                                           and p1.day   = cast(extract( DAY from date '{datareferencia}')  as varchar)
          		               ) pseq
          							inner join linhas li  on (pseq.cod_linha = li.COD and pseq.datareferencia = li.datareferencia)
          							 order by pseq.cod_linha
          							,pseq.sentido_linha
          							,pseq.seq_inicio
          							,pseq.seq_fim
          )
                   select distinct
                       cod_linha
                      ,sentido_linha
                      ,cast(seq_inicio as int) as seq_inicio
                      ,cast(seq_fim as int) as seq_fim
                      ,ponto_inicio
                      ,nome_ponto_inicio
                      ,ponto_final
                      ,nome_ponto_final
                      ,categoria_servico
                      ,nome_linha
                      ,nome_cor
                      ,somente_cartao
                      ,l.year
                      ,l.month
                      ,l.day
                  from  rota_sequenciada rt
                      left join vlinhas l on (rt.cod_linha = l.cod)
                  order by  seq_inicio,seq_fim
    ) q1"

  trip-endpoints: "(
  								with vlinhas as (
                                                   select  distinct cod,
                                                               year,
                                                               month,
                                                               day,
                                                               datareferencia
                                                   from (
                                                       select l.cod,
                   	                                    v.year as year,
                   	                                    v.month as month,
                   	                                    v.day as day,
                   	                                    l.datareferencia
                                                       from veiculos v
                                                           right join linhas l on (v.cod_linha = l.cod and l.year = v.year and l.month = v.month  and l.day = v.day)
                                                       where  l.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                             							  and l.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                             							  and l.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
                                                   ) as l
                                             ),
                                           start_end as (
                                                   select  bs.cod
                                                           ,bs.sentido
                                                           ,min(cast(bs.seq as int)) as start_trip
                                                           ,max(cast(bs.seq as int)) as end_trip
                                                           ,l.year
                                                           ,l.month
                                                           ,l.day
                                                   from pontoslinha bs
                                                      left join vlinhas l  on (bs.cod = l.cod and bs.datareferencia = l.datareferencia)
                                                   group by bs.cod,bs.sentido,l.year,l.month,l.day
                                           )
                                           select ps.cod     as line_code
                                                 ,ps.sentido
                                                 ,ps.num     as origin
                                                 ,ps.nome    as ponto_origem
                                                 ,pe.num     as destination
                                                 ,pe.nome    as ponto_destino
                                                 ,ss.year
                                                 ,ss.month
                                                 ,ss.day
                                           from start_end  ss
                                           inner join pontoslinha ps on (ps.cod = ss.cod  and ps.sentido = ss.sentido and cast(ps.seq as int) = ss.start_trip and ss.year = ps.year and ss.month = ps.month and ss.day = ps.day)
                                           inner join pontoslinha pe on (pe.cod = ss.cod  and pe.sentido = ss.sentido and cast(pe.seq as  int) = ss.end_trip and pe.year = ps.year and pe.month = ps.month and pe.day = ps.day)
                                           where pe.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                             				 and pe.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                             			     and pe.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
      ) q1"

  schedules: "( 
               with linhas as (
                          select  distinct cod,
                                      year,
                                      month,
                                      day
                                from (
                                  select l.cod,
                                         v.year as year,
                                         v.month as month,
                                         v.day as day
                                  from veiculos v
                                  right join linhas l on (v.cod_linha = l.cod and l.year = v.year and l.month = v.month  and l.day = v.day)
                                  where l.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                            	    and l.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                                    and l.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
                          ) as l
                      )
                      select t.cod_linha
                            ,t.cod_ponto
                            ,t.horario
                            ,t.nome_linha
                            ,t.tabela
                            ,t.veiculo
                            ,l.year
                            ,l.month
                            ,l.day
                      from tabelaveiculo t
                          left join linhas l on (t.cod_linha = l.cod)
                      where t.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                        and t.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                        and t.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
                      order by cod_linha,horario
          ) q1"

  trips: "(
          with linhas as (
                  select  distinct cod,
                          year,
                          month,
                          day
                  from (
                      select l.cod,
                              v.year as year,
                              v.month as month,
                              v.day as day
                      from veiculos v
                      right join linhas l on (v.cod_linha = l.cod and l.year = v.year and l.month = v.month  and l.day = v.day)
                      where  l.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                             and l.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                             and l.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
                    ) as l
                 ),
            trips as (
                select cod_linha     as line_code
                      ,cod_ponto     as start_point
                      ,horario       as start_time
                      ,tabela        as time_table
                      ,veiculo       as vehicle
                      ,lead(horario) over(partition by cod_linha,tabela,veiculo order by cod_linha, horario)   as end_time
                      ,lead(cod_ponto) over(partition by cod_linha,tabela,veiculo order by cod_linha, horario) as end_point
                from tabelaveiculo tv 
                where  tv.year = cast(extract( YEAR from date '{datareferencia}') as varchar)
                   and tv.month= cast(extract( MONTH from date '{datareferencia}') as varchar)
                   and tv.day = cast(extract( DAY from date '{datareferencia}')  as varchar)
                order by cod_linha,horario
            )
            select t.line_code
                  ,t.start_point
                  ,t.start_time
                  ,t.time_table
                  ,t.vehicle
                  ,t.end_time
                  ,t.end_point
                  ,l.year
                  ,l.month
                  ,l.day
            from trips t left join linhas l  on (t.line_code = l.cod)
    ) q1"

neo4j_import:
  lines:
    cypher_query: >
       LOAD CSV WITH HEADERS FROM 'file:///lines/{datareferencia}/lines.csv' AS row
       MERGE (l:Line {line_code: row.cod , name: row.nome})
       ON CREATE SET    l.line_code  = row.cod
                       ,l.category   = row.categoria_servico
                       ,l.name       = row.nome
                       ,l.color      = row.nome_cor
                       ,l.card_only  = row.somente_cartao

  lines_timetree:
    cypher_query: >
        LOAD CSV WITH HEADERS FROM 'file:///lines/{datareferencia}/lines.csv' AS row
        with row where NOT toInteger(row.year) IS NULL
        match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)}), (l:Line {line_code:row.cod,name:row.nome})
        with d,l
        merge (d)-[r2:EXISTS_LINE]->(l)

  busstops:
    cypher_query: >
        USING PERIODIC COMMIT 10000
        LOAD CSV WITH HEADERS FROM 'file:///busstops/{datareferencia}/busstops.csv' AS row
        MERGE (bs:BusStop {number: row.num, name: row.nome})
        ON CREATE SET  bs.name   = row.nome
                      ,bs.number    = row.num
                      ,bs.type      = row.tipo
                      ,bs.geometry  = 'POINT(' + row.lon +' '+ row.lat +')'
                      ,bs.latitude  = row.lat
                      ,bs.longitude = row.lon

  busstops_timetree:
    cypher_query: >
        USING PERIODIC COMMIT 20000  
        LOAD CSV WITH HEADERS FROM 'file:///busstops/{datareferencia}/busstops.csv' AS row
        with row where NOT toInteger(row.year) IS NULL
          match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)}), (bs:BusStop {number: row.num})
          with d,bs
          merge (d)-[:EXISTS_BUS_STOP]->(bs)

  routes:
    cypher_query: >
      USING PERIODIC COMMIT 21000
      LOAD CSV WITH HEADERS FROM "file:///routes/{datareferencia}/routes.csv" AS row
      MATCH (bss: BusStop {number: row.ponto_inicio})
      MATCH (bse: BusStop {number: row.ponto_final})
      MERGE (bss) -[:NEXT_STOP {
                         line_code: row.cod_linha
                        ,line_way: row.sentido_linha
                        ,service_category: row.categoria_servico
                        ,line_name: row.nome_linha
                        ,color_name: row.nome_cor
                        ,card_only: row.somente_cartao
      }]->(bse)

  routes_distance:
    cypher_query: >
      MATCH (p1:BusStop)-[r:NEXT_STOP]->(p2:BusStop) WHERE NOT EXISTS(r.distance)
          SET r.distance = distance(point({longitude: toFloat(p1.longitude),latitude: toFloat(p1.latitude) ,crs: 'wgs-84'})
          ,point({longitude: toFloat(p2.longitude),latitude: toFloat(p2.latitude) ,crs: 'wgs-84'}))


  trip_endpoints:
    cypher_query: >
      USING PERIODIC COMMIT 10000
       LOAD CSV WITH HEADERS FROM "file:///trip-endpoints/{datareferencia}/trip-endpoints.csv" AS row
        MATCH (l:Line {line_code:row.line_code}),(bs0:BusStop {number:row.origin}),(bs1:BusStop {number:row.destination})
        MERGE (l)-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})
        MERGE (t)-[:STARTS_ON_POINT]->(bs0)
        MERGE (t)-[:ENDS_ON_POINT]->(bs1)

  
  vehicles:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
      with distinct row.vehicle as vehicle where NOT vehicle = ""
      merge (v:Vehicle {vehicle:vehicle})
      
  vehicles_timetree:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
      with row where NOT toInteger(row.year) IS NULL
      with distinct row.vehicle as vehicle, row.year as year, row.month as month, row.day as day
      MATCH (y:Year {value:toInteger(year)})-[:CONTAINS]->(m:Month {value: toInteger(month)})-[:CONTAINS]->(d:Day {value: toInteger(day)}),(v:Vehicle {vehicle:vehicle})
      WITH d,v
      MERGE (d)-[:EXISTS_VEHICLE]->(v)

  trip_timetree:
    cypher_query: >
      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""
      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:EXISTS_LINE]->(l:Line {line_code:row.line_code})-[:HAS_TRIP]->(t:Trip)-[:STARTS_ON_POINT]->(bss:BusStop {number:row.start_point})
      with distinct d , t 
      MERGE (d)-[:EXISTS_TRIP]->(t)

  schedules:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""
      with distinct row.start_time as start_time, row.end_time as end_time, row.time_table as time_table, row.line_code as line_code, row.start_point as start_point 
      MERGE (s:Schedule {start_time:start_time, end_time:end_time, time_table:time_table, line_code:line_code, start_point: start_point})

  schedules_timetree:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""
      MATCH (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)}), (s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point: row.start_point})
      MERGE (d)-[:EXISTS_SCHEDULE]->(s)
  

  trip_schedules:
    cypher_query: >
        USING PERIODIC COMMIT 5000
        LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
        with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""
        match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[r2:EXISTS_LINE]->(l:Line )-[:HAS_TRIP]->(t:Trip)-[:STARTS_ON_POINT]->(bs:BusStop) 
        with distinct l, t, bs.number as start_point
        match (s:Schedule {line_code:l.line_code, start_point:start_point}) 
        with t, s
        MERGE (t)-[:HAS_SCHEDULE_AT]->(s)

  vehicle_schedules:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""
      MATCH (s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point: row.start_point}), (v:Vehicle {vehicle: row.vehicle})
      MERGE (v)-[:HAS_VEHICLE_SCHEDULE]->(s)

  line_schedules:
    cypher_query: >
      USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM "file:///trips/{datareferencia}/trips.csv" AS row
      with row where NOT toInteger(row.year) IS NULL and not row.vehicle = "" and not row.start_time ="" and not row.end_time = "" and not row.time_table =""
      MATCH (s:Schedule {start_time:row.start_time, end_time:row.end_time, time_table:row.time_table, line_code:row.line_code, start_point: row.start_point}), (l:Line {line_code:row.line_code})
      MERGE (l)-[:HAS_LINE_SCHEDULE]->(s)

  hour_timetree:
    cypher_query: >
        USING PERIODIC COMMIT 5000
        LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row 
        with distinct row.year as year, row.month as month , row.day as day, row.hour as hour, row.minute as minute
        match (y:Year {value:toInteger(year)})-[:CONTAINS]->(m:Month {value: toInteger(month)})-[:CONTAINS]->(d:Day {value: toInteger(day)})
        with distinct d, hour 
        merge (d)-[:CONTAINS]->(h:Hour {value: toInteger(hour)}) 

  minute_timetree:
    cypher_query: >
        USING PERIODIC COMMIT 5000
        LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row 
        with distinct row.year as year, row.month as month , row.day as day, row.hour as hour, row.minute as minute
        match (y:Year {value:toInteger(year)})-[:CONTAINS]->(m:Month {value: toInteger(month)})-[:CONTAINS]->(d:Day {value: toInteger(day)})-[:CONTAINS]->(h:Hour {value: toInteger(hour)})
        with distinct h, minute 
        merge (h)-[:CONTAINS]->(mi:Minute {value: toInteger(minute)})

  stops:
    cypher_query: >    
        USING PERIODIC COMMIT 20000
        LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
        create (s:Stop {geometry : 'POINT(' + row.longitude +' '+ row.latitude +')', latitude:row.latitude, longitude:row.longitude,event_timestamp:row.stop_timestamp, event_time:row.event_time,line_code: row.cod_linha})


  stops_timetree:
    cypher_query: >
      USING PERIODIC COMMIT 20000
      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
      match (y:Year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:CONTAINS]->(h:Hour {value: toInteger(row.hour)})-[:CONTAINS]->(mi:Minute {value: toInteger(row.minute)}), (s:Stop {latitude:row.latitude, longitude:row.longitude,event_timestamp:row.stop_timestamp, event_time:row.event_time,line_code: row.cod_linha})
      with distinct mi , s 
      create (mi)-[:EXISTS_STOP]->(s)
 
  vehicle_stops:
    cypher_query: >
      USING PERIODIC COMMIT 20000
      LOAD CSV WITH HEADERS FROM 'file:///stopevents/{datareferencia}/stopevents.csv' AS row
      match (v:Vehicle {vehicle: row.vehicle}), (s:Stop {line_code: row.cod_linha,latitude:row.latitude, longitude:row.longitude, event_time:row.event_time})
      with v, s
      create (v)-[:VEHICLE_HAS_STOPPED]->(s)

  trackingdata: #trackingdata.csv
    cypher_query: >
      USING PERIODIC COMMIT 20000
      LOAD CSV WITH HEADERS FROM 'file:///trackingdata/{datareferencia}/trackingdata.csv' AS row
      with row where toFloat(row.delta_time) <= 1200
      MATCH (v:Vehicle {vehicle: row.veic})-[:VEHICLE_HAS_STOPPED]->(s0:Stop {line_code: row.cod_linha, event_timestamp:row.last_stop}), (v:Vehicle {vehicle: row.veic})-[:VEHICLE_HAS_STOPPED]->(s1:Stop {line_code: row.cod_linha, event_timestamp:row.current_stop})
      merge (s0)-[m:MOVED_TO {delta_time: row.delta_time, delta_distance: row.delta_distance, delta_velocity:row.delta_velocity}]->(s1)

  event-stop-edges: #event-stop-edges.csv
    cypher_query: >
      USING PERIODIC COMMIT 20000
      LOAD CSV WITH HEADERS FROM "file:///event-stop-edges/{datareferencia}/event-stop-edges.csv" AS row
      MATCH (s:Stop {line_code:row.line_code,latitude:row.latitude,longitude:row.longitude,event_time:row.event_time}),(bs:BusStop {number:row.bus_stop_number})
      MERGE (s)-[e:EVENT_STOP {line_way:row.line_way}]->(bs)