base_url: "http://dadosabertos.c3sl.ufpr.br/curitibaurbs/"

etl_tasks:
  tabela_linhas:
    folder: "linhas"
    file: "linhas.json.xz"

  pontos_linha:
    folder: "pontoslinha"
    file: "pontosLinha.json.xz"

  tabela_linha:
    folder: "tabelalinha"
    file: "tabelaLinha.json.xz"

  tabela_trechositinerarios:
    folder: "trechositinerarios"
    file: "trechosItinerarios.json.xz"

  tabela_tabelaveiculo:
    folder: "tabelaveiculo"
    file: "tabelaVeiculo.json.xz"

#  tabela_shapelinha:
#    folder: "shapelinha"
#    file: "shapeLinha.json.xz"

  tabela_veiculos:
    folder: "veiculos"
    file: "veiculos.json.xz"

etl_queries:
  lines: (select cod, categoria_servico, nome, nome_cor, somente_cartao from linhas_stg) q1
  busstops: (select distinct nome, num, tipo, lat, lon from pontoslinha_stg) q1
  routes: "(

          select distinct
            cod_linha
            ,sentido_linha
            ,cast(seq_inicio as int) as seq_inicio
            ,cast(seq_fim as int) as seq_fim
            ,ponto_inicio
            ,nome_ponto_inicio
            ,ponto_final
            ,nome_ponto_final
            ,categoria_servico
            ,nome_linha
            ,nome_cor
            ,somente_cartao
        from (select 	 pseq.cod_linha
                                          ,pseq.sentido_linha
                                          ,pseq.seq_inicio
                                          ,pseq.seq_fim
                                          ,pseq.ponto_inicio
                                          ,pseq.nome_ponto_inicio
                                          ,pseq.ponto_final
                                          ,pseq.nome_ponto_final
                                          ,li.CATEGORIA_SERVICO as categoria_servico
                                          ,li.NOME as nome_linha
                                          ,li.NOME_COR as nome_cor
                                          ,li.SOMENTE_CARTAO as somente_cartao
                                          ,pseq.datareferencia
                                          from (select
                                          p1.COD as cod_linha
                                          ,p1.SENTIDO  as sentido_linha
                                          ,p1.SEQ      as seq_inicio
                                          ,p2.SEQ      as seq_fim
                                          ,p1.NUM      as ponto_inicio
                                          ,p1.NOME     as nome_ponto_inicio
                                          ,p2.NUM      as ponto_final
                                          ,p2.NOME     as nome_ponto_final
                                          ,p1.datareferencia
                                          from pontoslinha_stg P1 inner join pontoslinha_stg p2 on (cast(p1.SEQ as int) +1 = cast(p2.SEQ as int) and p1.COD = p2.COD and p1.SENTIDO = p2.SENTIDO and p1.datareferencia = p2.datareferencia)
                                          ) pseq
                                          inner join linhas_stg li  on (pseq.cod_linha = li.COD and pseq.datareferencia = li.datareferencia)
                                          order by pseq.cod_linha
                                          ,pseq.sentido_linha
                                          ,pseq.seq_inicio
                                          ,pseq.seq_fim
                                          ) as rota_sequenciada
        order by  seq_inicio,seq_fim
    ) q1"

  trip-endpoints: ( with start_end as
                    (
                        select  cod
                        ,sentido
                        ,min(cast(seq as int)) as start_trip
                        ,max(cast(seq as int)) as end_trip
                        from pontoslinha_stg
                        group by cod,sentido
                    )
                    select ps.cod     as line_code
                        ,ps.sentido
                        ,ps.num     as origin
                        ,ps.nome    as ponto_origem
                        ,pe.num     as destination
                        ,pe.nome    as ponto_destino
                    from start_end  ss
                      inner join pontoslinha_stg ps on (ps.cod = ss.cod  and ps.sentido = ss.sentido and cast(ps.seq as int) = ss.start_trip)
                      inner join pontoslinha_stg pe on (pe.cod = ss.cod  and pe.sentido = ss.sentido and cast(pe.seq as  int) = ss.end_trip) ) q1

  schedules: ( select cod_linha
              ,cod_ponto
              ,horario
              ,nome_linha
              ,tabela
              ,veiculo
              from tabelaveiculo_stg
              order by cod_linha,horario
          ) q1

  trips: (with query_1
          as (
            select cod_linha     as line_code
            ,cod_ponto     as start_point
            ,horario       as start_time
            ,tabela        as time_table
            ,veiculo       as vehicle
            ,lead(horario) over(partition by cod_linha,tabela,veiculo order by cod_linha, horario)   as end_time
            ,lead(cod_ponto) over(partition by cod_linha,tabela,veiculo order by cod_linha, horario) as end_point
            from tabelaveiculo_stg
            order by cod_linha,horario
          )
    select * from query_1   ) q1


neo4j_import:
  lines:
    cypher_query:
      LOAD CSV WITH HEADERS FROM 'file:///lines.csv' AS row
            CREATE (l:Line)
            set   l.line_code  = row.cod
            ,l.category   = row.categoria_servico
            ,l.name       = row.nome
            ,l.color      = row.nome_cor
            ,l.card_only  = row.somente_cartao
            RETURN count(l);

  busstops:
    cypher_query:
        USING PERIODIC COMMIT 10000
             LOAD CSV WITH HEADERS FROM "file:///busstops.csv" AS row
             create (bs:BusStop)
             set bs.name       = row.nome
                 ,bs.number    = row.num
                 ,bs.type      = row.tipo
                 ,bs.geometry  = 'POINT(' + row.lon +' '+ row.lat +')'
              ,bs.latitude  = row.lat
              ,bs.longitude = row.lon
              WITH bs
              CALL spatial.addNode('layer_curitiba',bs) YIELD node
              RETURN count(node);
  routes:
    cypher_query:
      'USING PERIODIC COMMIT 1000
      LOAD CSV WITH HEADERS FROM "file:///routes.csv" AS row
      MATCH(bss: BusStop {number: row.ponto_inicio}), (bse: BusStop {number: row.ponto_final})
      CREATE(bss) - [: NEXT_STOP {
         line_code: row.cod_linha
        ,line_way: row.sentido_linha
        ,service_category: row.categoria_servico
        ,line_name: row.nome_linha
        ,color_name: row.nome_cor
        ,card_only: row.somente_cartao
      }]->(bse)'

  routes_distance:
    cypher_query:
      "MATCH (p1:BusStop)-[r:NEXT_STOP]->(p2:BusStop)
          SET r.distance = distance(point({longitude: toFloat(p1.longitude),latitude: toFloat(p1.latitude) ,crs: 'wgs-84'})
          ,point({longitude: toFloat(p2.longitude),latitude: toFloat(p2.latitude) ,crs: 'wgs-84'}))"

  trip_endpoints:
    cypher_query:
      'USING PERIODIC COMMIT 10000
       LOAD CSV WITH HEADERS FROM "file:///trip-endpoints.csv" AS row
        MATCH(l:Line {line_code:row.line_code}),(bs0:BusStop {number:row.origin}),(bs1:BusStop {number:row.destination})
        MERGE(l)-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})
        MERGE(t)-[:STARTS_ON_POINT]->(bs0)
        MERGE(t)-[:ENDS_ON_POINT]->(bs1)'

  trips:
    cypher_query:
      'USING PERIODIC COMMIT 10000
       LOAD CSV WITH HEADERS FROM "file:///trips.csv" AS row
        MATCH (l:Line {line_code:row.line_code})-[:HAS_TRIP]->
        (t:Trip)-[:STARTS_ON_POINT]->(bss:BusStop {number:row.start_point}),(t)-[:ENDS_ON_POINT]->(bse:BusStop {number:row.end_point})
        MERGE(t)-[:HAS_SCHEDULE_AT]->(s:Schedule {start_time:row.start_time,end_time:row.end_time,time_table:row.time_table,vehicle:row.vehicle})'

  vehicles:
    cypher_query:
      USING PERIODIC COMMIT 1000
      LOAD CSV WITH HEADERS FROM "file:///stopevents.csv" AS row
      with distinct row.vehicle  as vehicle
      CREATE (v:Vehicle {vehicle:vehicle})
      return count(v)

  stop_events:
    cypher_query:
      "USING PERIODIC COMMIT 10000
      LOAD CSV WITH HEADERS FROM 'file:///stopevents.csv' AS row
      CREATE (s:Stop {geometry : 'POINT(' + row.longitude +' '+ row.latitude +')', latitude:row.latitude, longitude:row.longitude,event_timestamp:row.stop_timestamp, event_time:row.event_time,line_code: row.cod_linha, vehicle:row.vehicle })
      return count(s)"

  trackingdata: #trackingdata.csv
    cypher_query:
      "USING PERIODIC COMMIT 1000
      LOAD CSV WITH HEADERS FROM 'file:///template' AS row
      with row where toFloat(row.delta_time) <= 1200
      MATCH (s0:Stop {event_timestamp:row.last_timestamp, vehicle:row.veic}),(s1:Stop {event_timestamp:row.event_timestamp,vehicle:row.veic})
      MERGE (s0)-[m:MOVED_TO {delta_time: row.delta_time, delta_distance: row.delta_distance, delta_velocity:row.delta_velocity}]->(s1)
      return count(m)"

  event-stop-edges: #event-stop-edges.csv
    cypher_query:
      USING PERIODIC COMMIT 1000
      LOAD CSV WITH HEADERS FROM "file:///template" AS row
      MATCH (s:Stop {line_code:row.line_code,latitude:row.latitude,longitude:row.longitude,vehicle:row.vehicle,event_time:row.event_time}),(bs:BusStop {number:row.bus_stop_number})
      MERGE(s)-[e:EVENT_STOP {line_way:row.line_way}]->(bs)
      return count(e)

