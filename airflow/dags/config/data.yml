base_url: "http://dadosabertos.c3sl.ufpr.br/curitibaurbs/"

etl_tasks:
  tabela_linhas:
    folder: "linhas"
    file: "linhas.json.xz"

  pontos_linha:
    folder: "pontoslinha"
    file: "pontosLinha.json.xz"

  tabela_linha:
    folder: "tabelalinha"
    file: "tabelaLinha.json.xz"

  tabela_trechositinerarios:
    folder: "trechositinerarios"
    file: "trechosItinerarios.json.xz"

  tabela_tabelaveiculo:
    folder: "tabelaveiculo"
    file: "tabelaVeiculo.json.xz"

  tabela_veiculos:
    folder: "veiculos"
    file: "veiculos.json.xz"

etl_queries:
  lines: "(
          select distinct cod,
                        categoria_servico,
                        nome,
                        nome_cor,
                        somente_cartao,
                        year,
                        month,
                        day
                    from (
                        select l.cod,
                            l.categoria_servico,
                            l.nome,
                            l.nome_cor,
                            l.somente_cartao,
                            v.year as year,
                            v.month as month,
                            v.day as day
                        from veiculos_stg v
                          right join linhas_stg l on (v.cod_linha = l.cod)
                          ) t
          order by cod,year,month,day
  ) q1"

  busstops: "(with linhas as (
                          select  distinct cod,
                                  categoria_servico,
                                  nome,
                                  nome_cor,
                                  somente_cartao,
                                  year,
                                  month,
                                  day
                          from (
                              select l.cod,
                                  l.categoria_servico,
                                  l.nome,
                                  l.nome_cor,
                                  l.somente_cartao,
                                  v.year as year,
                                  v.month as month,
                                  v.day as day
                              from veiculos_stg v
                              right join linhas_stg l on (v.cod_linha = l.cod)
                            ) as l
                          )
                          select distinct
                                     bs.nome
                                    ,bs.num
                                    ,bs.tipo
                                    ,bs.lat
                                    ,bs.lon
                                    ,l.year
                                    ,l.month
                                    ,l.day
                          from     pontoslinha_stg	bs
                          inner join linhas l on (bs.cod = l.cod)
    ) q1"

  routes: "(
          with linhas as (
          	select  distinct cod,
          	              year,
                          month,
                          day
          	       from (
          			select l.cod,
          			       v.year as year,
                           v.month as month,
                           v.day as day
          			from veiculos_stg v
          			right join linhas_stg l on (v.cod_linha = l.cod)
          		) as l
          	),
          	rota_sequenciada as  (
          		select 	  pseq.cod_linha
          		         ,pseq.sentido_linha
          		         ,pseq.seq_inicio
          		         ,pseq.seq_fim
          		         ,pseq.ponto_inicio
          		         ,pseq.nome_ponto_inicio
          		         ,pseq.ponto_final
          		         ,pseq.nome_ponto_final
          		         ,li.CATEGORIA_SERVICO as categoria_servico
          		         ,li.NOME as nome_linha
          		         ,li.NOME_COR as nome_cor
          		         ,li.SOMENTE_CARTAO as somente_cartao
          		         ,pseq.datareferencia
          		         from (
          		          		select
          		                	  p1.COD as cod_linha
          		                     ,p1.SENTIDO  as sentido_linha
          		                     ,p1.SEQ      as seq_inicio
          		                     ,p2.SEQ      as seq_fim
          		                     ,p1.NUM      as ponto_inicio
          		                     ,p1.NOME     as nome_ponto_inicio
          		                     ,p2.NUM      as ponto_final
          		                     ,p2.NOME     as nome_ponto_final
          		                     ,p1.datareferencia
          		                     	from pontoslinha_stg P1
          		                     	inner join pontoslinha_stg p2 on (cast(p1.SEQ as int) +1 = cast(p2.SEQ as int) and p1.COD = p2.COD and p1.SENTIDO = p2.SENTIDO and p1.datareferencia = p2.datareferencia)
          		               ) pseq
          							inner join linhas_stg li  on (pseq.cod_linha = li.COD and pseq.datareferencia = li.datareferencia)
          							 order by pseq.cod_linha
          							,pseq.sentido_linha
          							,pseq.seq_inicio
          							,pseq.seq_fim
          )
                   select distinct
                       cod_linha
                      ,sentido_linha
                      ,cast(seq_inicio as int) as seq_inicio
                      ,cast(seq_fim as int) as seq_fim
                      ,ponto_inicio
                      ,nome_ponto_inicio
                      ,ponto_final
                      ,nome_ponto_final
                      ,categoria_servico
                      ,nome_linha
                      ,nome_cor
                      ,somente_cartao
                      ,l.year
                      ,l.month
                      ,l.day
                  from  rota_sequenciada rt left join linhas l on (rt.cod_linha = l.cod)
                  order by  seq_inicio,seq_fim
    ) q1"

  trip-endpoints: "(
                    with linhas as (
                                select  distinct cod,
                                            year,
                                            month,
                                            day
                                from (
                                    select l.cod,
                                    v.year as year,
                                    v.month as month,
                                    v.day as day
                                    from veiculos_stg v right join linhas_stg l on (v.cod_linha = l.cod)
                                ) as l
                          ),
                        start_end as (
                                select  bs.cod
                                        ,bs.sentido
                                        ,min(cast(bs.seq as int)) as start_trip
                                        ,max(cast(bs.seq as int)) as end_trip
                                        ,l.year
                                        ,l.month
                                        ,l.day
                                from pontoslinha_stg bs left join linhas l  on (bs.cod = l.cod)
                                group by bs.cod,bs.sentido,l.year,l.month,l.day
                        )
                        select ps.cod     as line_code
                              ,ps.sentido
                              ,ps.num     as origin
                              ,ps.nome    as ponto_origem
                              ,pe.num     as destination
                              ,pe.nome    as ponto_destino
                              ,ss.year
                              ,ss.month
                              ,ss.day
                        from start_end  ss
                        inner join pontoslinha_stg ps on (ps.cod = ss.cod  and ps.sentido = ss.sentido and cast(ps.seq as int) = ss.start_trip)
                        inner join pontoslinha_stg pe on (pe.cod = ss.cod  and pe.sentido = ss.sentido and cast(pe.seq as  int) = ss.end_trip)
      ) q1"

  schedules: "( with linhas as (
                          select  distinct cod,
                                      year,
                                      month,
                                      day
                                from (
                                  select l.cod,
                                         v.year as year,
                                         v.month as month,
                                         v.day as day
                                  from veiculos_stg v
                                  right join linhas_stg l on (v.cod_linha = l.cod)
                          ) as l
                      )
                      select t.cod_linha
                            ,t.cod_ponto
                            ,t.horario
                            ,t.nome_linha
                            ,t.tabela
                            ,t.veiculo
                            ,l.year
                            ,l.month
                            ,l.day
                      from tabelaveiculo_stg t left join linhas l on (t.cod_linha = l.cod)
                      order by cod_linha,horario
          ) q1"

  trips: "(
        with linhas as (
                  select  distinct cod,
                          year,
                          month,
                          day
                  from (
                      select l.cod,
                              v.year as year,
                              v.month as month,
                              v.day as day
                      from veiculos_stg v
                      right join linhas_stg l on (v.cod_linha = l.cod)
                    ) as l
                 ),
            trips as (
                select cod_linha     as line_code
                      ,cod_ponto     as start_point
                      ,horario       as start_time
                      ,tabela        as time_table
                      ,veiculo       as vehicle
                      ,lead(horario) over(partition by cod_linha,tabela,veiculo order by cod_linha, horario)   as end_time
                      ,lead(cod_ponto) over(partition by cod_linha,tabela,veiculo order by cod_linha, horario) as end_point
                from tabelaveiculo_stg
                order by cod_linha,horario
            )
            select t.line_code
                  ,t.start_point
                  ,t.start_time
                  ,t.time_table
                  ,t.vehicle
                  ,t.end_time
                  ,t.end_point
                  ,l.year
                  ,l.month
                  ,l.day
            from trips t left join linhas l  on (t.line_code = l.cod)
    ) q1"

neo4j_import:
  lines:
    cypher_query:
      "LOAD CSV WITH HEADERS FROM 'file:///lines.csv' AS row
       MERGE (l:Line {line_code: row.cod , name: row.nome})
       ON CREATE SET    l.line_code  = row.cod
                       ,l.category   = row.categoria_servico
                       ,l.name       = row.nome
                       ,l.color      = row.nome_cor
                       ,l.card_only  = row.somente_cartao
       return count(l)"

  lines_timetree:
    cypher_query:
      "LOAD CSV WITH HEADERS FROM 'file:///lines.csv' AS row
      with row where NOT toInteger(row.year) IS NULL
      merge (y:year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_LINE]->(l:Line {line_code:row.cod,name:row.nome})
      return count(l)"

  busstops:
    cypher_query:
          "USING PERIODIC COMMIT 10000
          LOAD CSV WITH HEADERS FROM 'file:///busstops.csv' AS row
          MERGE (bs:BusStop {number: row.num, name: row.nome})
          ON CREATE SET  bs.name   = row.nome
                        ,bs.number    = row.num
                        ,bs.type      = row.tipo
                        ,bs.geometry  = 'POINT(' + row.lon +' '+ row.lat +')'
                        ,bs.latitude  = row.lat
                        ,bs.longitude = row.lon
          WITH bs
          CALL spatial.addNode('layer_curitiba',bs) YIELD node
          RETURN count(node);"

  busstops_timetree:
    cypher_query:
        "LOAD CSV WITH HEADERS FROM 'file:///busstops.csv' AS row
        with row where NOT toInteger(row.year) IS NULL
        merge (y:year {value:toInteger(row.year)})-[:CONTAINS]->(m:Month {value: toInteger(row.month)})-[:CONTAINS]->(d:Day {value: toInteger(row.day)})-[:HAS_BUS_STOP]->(bs:BusStop {number: row.num, name:row.nome})
        return count(bs)"


  routes:
    cypher_query:
      'USING PERIODIC COMMIT 1000
      LOAD CSV WITH HEADERS FROM "file:///routes.csv" AS row
      MATCH (bss: BusStop {number: row.ponto_inicio}), (bse: BusStop {number: row.ponto_final})
      MERGE (bss) -[:NEXT_STOP {
                         line_code: row.cod_linha
                        ,line_way: row.sentido_linha
                        ,service_category: row.categoria_servico
                        ,line_name: row.nome_linha
                        ,color_name: row.nome_cor
                        ,card_only: row.somente_cartao
      }]->(bse)'

  routes_distance:
    cypher_query:
      "MATCH (p1:BusStop)-[r:NEXT_STOP]->(p2:BusStop) WHERE NOT EXISTS(r.distance)
          SET r.distance = distance(point({longitude: toFloat(p1.longitude),latitude: toFloat(p1.latitude) ,crs: 'wgs-84'})
          ,point({longitude: toFloat(p2.longitude),latitude: toFloat(p2.latitude) ,crs: 'wgs-84'}))"

#  trip_endpoints:
#    cypher_query:
#      'USING PERIODIC COMMIT 10000
#       LOAD CSV WITH HEADERS FROM "file:///trip-endpoints.csv" AS row
#        MATCH (l:Line {line_code:row.line_code}),(bs0:BusStop {number:row.origin}),(bs1:BusStop {number:row.destination})
#        MERGE (l)-[:HAS_TRIP]->(t:Trip {line_way:row.sentido})
#        MERGE (t)-[:STARTS_ON_POINT]->(bs0)
#        MERGE (t)-[:ENDS_ON_POINT]->(bs1)'

#  trips:
#    cypher_query:
#      'USING PERIODIC COMMIT 10000
#       LOAD CSV WITH HEADERS FROM "file:///trips.csv" AS row
#        MATCH (l:Line {line_code:row.line_code})-[:HAS_TRIP]->
#        (t:Trip)-[:STARTS_ON_POINT]->(bss:BusStop {number:row.start_point}),(t)-[:ENDS_ON_POINT]->(bse:BusStop {number:row.end_point})
#        MERGE(t)-[:HAS_SCHEDULE_AT]->(s:Schedule {start_time:row.start_time,end_time:row.end_time,time_table:row.time_table,vehicle:row.vehicle})'
#
#  vehicles:
#    cypher_query:
#      USING PERIODIC COMMIT 1000
#      LOAD CSV WITH HEADERS FROM "file:///stopevents.csv" AS row
#      with distinct row.vehicle  as vehicle
#      CREATE (v:Vehicle {vehicle:vehicle})
#      return count(v)
#
#  stop_events:
#    cypher_query:
#      "USING PERIODIC COMMIT 10000
#      LOAD CSV WITH HEADERS FROM 'file:///stopevents.csv' AS row
#      CREATE (s:Stop {geometry : 'POINT(' + row.longitude +' '+ row.latitude +')', latitude:row.latitude, longitude:row.longitude,event_timestamp:row.stop_timestamp, event_time:row.event_time,line_code: row.cod_linha, vehicle:row.vehicle })
#      return count(s)"
#
#  trackingdata: #trackingdata.csv
#    cypher_query:
#      "USING PERIODIC COMMIT 1000
#      LOAD CSV WITH HEADERS FROM 'file:///template' AS row
#      with row where toFloat(row.delta_time) <= 1200
#      MATCH (s0:Stop {event_timestamp:row.last_timestamp, vehicle:row.veic}),(s1:Stop {event_timestamp:row.event_timestamp,vehicle:row.veic})
#      MERGE (s0)-[m:MOVED_TO {delta_time: row.delta_time, delta_distance: row.delta_distance, delta_velocity:row.delta_velocity}]->(s1)
#      return count(m)"
#
#  event-stop-edges: #event-stop-edges.csv
#    cypher_query:
#      USING PERIODIC COMMIT 1000
#      LOAD CSV WITH HEADERS FROM "file:///template" AS row
#      MATCH (s:Stop {line_code:row.line_code,latitude:row.latitude,longitude:row.longitude,vehicle:row.vehicle,event_time:row.event_time}),(bs:BusStop {number:row.bus_stop_number})
#      MERGE(s)-[e:EVENT_STOP {line_way:row.line_way}]->(bs)
#      return count(e)

